"""
Language Instruction Addition Script for LabSim Dataset

This script reads an existing HDF5 dataset generated by data_collector.py and adds
language instruction fields to each episode. It saves the first frame of each
episode as an image and allows the user to select from predefined instructions or enter custom ones.

Usage:
    python add_language_instructions.py <dataset_path> [--instructions_file <path>] [--output_dir <path>]

Arguments:
    dataset_path: Path to the HDF5 dataset file (e.g., "output/dataset/episode_data.hdf5")
    --instructions_file: Optional path to a JSON file containing predefined instructions
    --output_dir: Optional directory to save episode images (default: "episode_images")

Example:
    python add_language_instructions.py output/dataset/episode_data.hdf5
    python add_language_instructions.py output/dataset/episode_data.hdf5 --instructions_file custom_instructions.json
    python add_language_instructions.py output/dataset/episode_data.hdf5 --output_dir my_images

The script will:
1. Load each episode from the HDF5 file
2. Save the first frame of each episode as an image
3. Present predefined instruction options or allow custom input
4. Save the selected instruction back to the HDF5 file
5. Create a backup of the original file before modification

Predefined instructions are provided for common lab tasks like picking, placing, pouring, etc.
"""

import os
import sys
import json
import h5py
import numpy as np
from PIL import Image
import argparse
from datetime import datetime
from typing import List, Dict, Optional
import shutil

# Default predefined instructions for common lab tasks
DEFAULT_INSTRUCTIONS = [
    "Pick up the object from the table",
    "Place the object on the designated location",
    "Pour liquid from the beaker into the flask",
    "Transfer the sample to the test tube",
    "Close the container lid",
    "Open the container lid",
    "Move the object to the workspace",
    "Clean the beaker with water",
    "Heat the solution in the beaker",
    "Stir the mixture in the container",
    "Measure the volume of liquid",
    "Add reagent to the solution",
    "Remove the object from the workspace",
    "Navigate to the target location",
    "Grasp the tool from the holder",
    "Return the tool to the holder",
    "Mix the chemicals in the beaker",
    "Filter the solution through the funnel",
    "Weigh the sample on the balance",
    "Record the experimental data"
]

def load_instructions_from_file(file_path: str) -> List[str]:
    """Load custom instructions from a JSON file"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
            if isinstance(data, list):
                return data
            elif isinstance(data, dict) and 'instructions' in data:
                return data['instructions']
            else:
                print(f"Warning: Invalid format in {file_path}, using default instructions")
                return DEFAULT_INSTRUCTIONS
    except Exception as e:
        print(f"Error loading instructions from {file_path}: {e}")
        print("Using default instructions")
        return DEFAULT_INSTRUCTIONS

def display_frame_with_instructions(frame: np.ndarray, episode_name: str, 
                                  instructions: List[str], output_dir: str = "episode_images") -> Optional[str]:
    """Save the first frame as image and get user instruction selection"""
    # Add debug information
    print(f"Displaying frame information:")
    print(f"  Original shape: {frame.shape}")
    print(f"  Data type: {frame.dtype}")
    print(f"  Value range: [{np.min(frame)}, {np.max(frame)}]")
    
    # Check if frame is empty or all zeros
    if frame is None:
        print("Error: Frame is None")
        return None
    
    if np.all(frame == 0):
        print("Warning: Frame is all zeros, possible data issue")
    
    # Ensure correct data type
    if frame.dtype != np.uint8:
        if np.max(frame) <= 1.0:
            frame = (frame * 255).astype(np.uint8)
        else:
            frame = frame.astype(np.uint8)
        print(f"  Converted value range: [{np.min(frame)}, {np.max(frame)}]")
    
    
    # Save frame as image
    image_path = f"show_image.png"
    Image.fromarray(frame).save(image_path)
    print(f"  Saved frame to: {image_path}")
    
    print(f"\n=== Episode: {episode_name} ===")
    print("Available instructions:")
    for i, instruction in enumerate(instructions, 1):
        print(f"{i:2d}. {instruction}")
    print("0. Enter custom instruction")
    print("-1. Skip this episode")
    
    while True:
        try:
            choice = input("\nSelect instruction number (or -1 to skip): ").strip()
            choice_num = int(choice)
            
            if choice_num == -1:
                return None
            elif choice_num == 0:
                custom_instruction = input("Enter custom instruction: ").strip()
                if custom_instruction:
                    return custom_instruction
                else:
                    print("Please enter a valid instruction")
                    continue
            elif 1 <= choice_num <= len(instructions):
                return instructions[choice_num - 1]
            else:
                print(f"Please enter a number between -1 and {len(instructions)}")
        except ValueError:
            print("Please enter a valid number")
        except KeyboardInterrupt:
            return None

def get_first_frame_from_episode(episode_group: h5py.Group) -> Optional[np.ndarray]:
    """Extract the first frame from an episode group"""
    # Look for camera data (assuming RGB images)
    for key in episode_group.keys():
        if key != 'agent_pose' and key != 'actions' and key != 'language_instruction':
            # This should be camera data
            camera_data = episode_group[key]
            print(f"Processing camera data: {key}, shape: {camera_data.shape}, type: {camera_data.dtype}")
            
            if len(camera_data.shape) == 4:  # [T, H, W, C]
                # Check time dimension
                if camera_data.shape[0] <= 20:
                    first_frame = camera_data[0]  # If time steps less than 20, take first frame
                else:
                    first_frame = camera_data[20]  # Otherwise take frame 20
                
                print(f"Extracted frame shape: {first_frame.shape}, value range: [{np.min(first_frame)}, {np.max(first_frame)}]")
                
                # Handle different channel formats
                if first_frame.shape[-1] == 3:  # [H, W, C] - RGB format
                    # Convert to BGR for OpenCV display
                    return first_frame
                elif first_frame.shape[0] == 3:  # [C, H, W] - channels first
                    # Convert to [H, W, C] format
                    return np.transpose(first_frame, (1, 2, 0))
                else:
                    # Other formats, return directly
                    return first_frame
                    
            elif len(camera_data.shape) == 3:  # [T, H, W] - grayscale
                first_frame = camera_data[0]
                print(f"Extracted grayscale frame shape: {first_frame.shape}, value range: [{np.min(first_frame)}, {np.max(first_frame)}]")
                # Convert to BGR
                return first_frame
    
    print("No valid camera data found")
    return None

def add_language_instructions(dataset_path: str, instructions: List[str], output_dir: str = "episode_images"):
    """Add language instructions to the HDF5 dataset"""
    
    # Create backup of original file
    backup_path = dataset_path + f".backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    print(f"Creating backup: {backup_path}")
    shutil.copy2(dataset_path, backup_path)
    
    # Open the dataset for reading and writing
    with h5py.File(dataset_path, 'r+') as h5_file:
        episode_names = list(h5_file.keys())
        total_episodes = len(episode_names)
        
        print(f"Found {total_episodes} episodes in the dataset")
        print("Starting to add language instructions...")
        
        for i, episode_name in enumerate(episode_names, 1):
            print(f"\nProcessing episode {i}/{total_episodes}: {episode_name}")
            
            episode_group = h5_file[episode_name]
            
            # Check if language instruction already exists
            if 'language_instruction' in episode_group:
                print(f"Episode {episode_name} already has language instruction, skipping...")
                continue
            
            # Get the first frame
            first_frame = get_first_frame_from_episode(episode_group)
            
            if first_frame is None:
                print(f"Could not extract first frame from episode {episode_name}, skipping...")
                continue
            
            # Display frame and get instruction
            instruction = display_frame_with_instructions(first_frame, episode_name, instructions, output_dir)
            
            if instruction is None:
                print(f"Skipping episode {episode_name}")
                continue
            
            # Save the instruction to the dataset
            episode_group.create_dataset('language_instruction', data=instruction.encode('utf-8'))
            print(f"Added instruction to episode {episode_name}: {instruction}")
            
            # Wait a bit for user to see the confirmation
            # cv2.waitKey(1000) # Removed cv2.waitKey
    
    print(f"\nCompleted! Added language instructions to the dataset.")
    print(f"Original file backed up as: {backup_path}")

def main():
    parser = argparse.ArgumentParser(description="Add language instructions to LabSim HDF5 dataset")
    parser.add_argument("dataset_path", help="Path to the HDF5 dataset file")
    parser.add_argument("--instructions_file", help="Path to JSON file with custom instructions")
    parser.add_argument("--output_dir", default="episode_images", help="Directory to save episode images")
    
    args = parser.parse_args()
    
    # Check if dataset file exists
    if not os.path.exists(args.dataset_path):
        print(f"Error: Dataset file '{args.dataset_path}' not found")
        sys.exit(1)
    
    # Load instructions
    if args.instructions_file:
        instructions = load_instructions_from_file(args.instructions_file)
    else:
        instructions = DEFAULT_INSTRUCTIONS
    
    print(f"Loaded {len(instructions)} instructions")
    print(f"Images will be saved to: {args.output_dir}")
    
    try:
        add_language_instructions(args.dataset_path, instructions, args.output_dir)
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main() 